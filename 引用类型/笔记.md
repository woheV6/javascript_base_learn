### 引用类型

- 引用类型是一种数据结构。用于将功能和数据组织在一起。
- 对象是某个特定引用类型的实例

### 对象

-  创建对象的方式？
  - new 构造函数
  - 字面量： {}
    - 字面量创建的对象 属性可以是字符串 数字，（数字会自动转换为字符串）
    - 访问属性有两种方式：.点、[] 方括号。方括号中可以跟变量

### 数组

- Array
  - 利用 length 可以灵活改变数组。
  - 检查是否是数组：Array.isArray(value)、instanceof
  - 转换方法
    - toString() valueOf()
    ```
        var list=[1,2,3,4]
        list.toString() // '1,2,3,4'
        list.valueOf() // [1,2,3,4]
        alert(list) // '1,2,3,4' alert接收一个字符串，他会自动调用toString()
    ```
- 栈方法
  - last-in-firstOut,后进先出的数据结构
  - push:插入，在数组的末尾插入一个或者多个值，返回数组的长度
  - pop：推出，在数组的末尾移除，返回移除的值
- 队列方法

  - shift 将数组第一个值弹出
  - unshift 在数组前端位插入一个或者多个值

- 重排序

  - sort 接收一个比较函数
  - reverse 单纯点反转数组

- 操作方法
  - concat:顾名思义就是连接数组，并不会影响原数组,返回值是一个新数组。
  - slice:基于当前数组创建一个或多个值的数组。可以接受一个或两个参数。并不会影响原数组。
    - 注意 当参数为负数时，用数组长度加上这个数再继续求职。
    - 当 第二个参数大于第一个参数当时候 返回空数组
  - splice 嘴刁的数组方法
    - 可以做删除，替换操作： array.splice(start_index,delete_number,add_arg),接收两个参数，第一个参数：从什么地方删除的索引，第二个 ：删除的个数，第三个参数 ： 插入的参数
    - 注意：splice 会影响原数组，返回值是删除的项组成的数组
- 位置方法

  - indexOf()
  - lastIndexOf()

- 迭代方法

  - every 全部为 true 才返回 true。不会遍历每一项
  - some 遍历每一项，只要又一个为 true 就会返回 true
  - filter 遍历每一项，筛选出 true 的项组成的数组
  - forEach  遍历每一项，无返回值
  - map 遍历每一项，返回每次函数调用结果返回的数组

    ```
        // 这几个方法的差异
        * every
        var list=[1,2,3,4,5,6]
        let r=list.every(item=>{
            console.log(item)
            return item>5
        })
        r=false
        这段代码只会输出1，便会停止

        * some
        var list=[1,2,3,4,5,6]
        let r=list.some(item=>{
            console.log(item)
            return item>5
        })
        r=true
        这段代码会输出每一项
    ```

- 归并方法

  - reduce
  - reduceRight

    - 接收两个参数，一个函数和一个初始值

    ```
    累加的栗子：
    var list=[1,2,3,4,5,6]
        let r=list.reduce((pre,cur,index,array)=>{
            return pre+cur
        },0)
    ```

### DATE 类型 使用的 UTC,没有日期偏差

- 1970-1-1 日起
- Date.UTC() //标准
- Date.parse() // 因地区有差异
- Date.now() 获取当前的时间戳
  ```
      const d = new Date();
      年份： console.log(d.getFullYear());
      月份： console.log(d.getMonth());
      日：   console.log(d.getDate());
      星期几：console.log(d.getDay());
      小时：console.log(d.getHours());
      分钟：console.log(d.getMinutes());
      秒：console.log(d.getSeconds());
      毫秒：console.log(d.getMilliseconds());
      console.log(d.getTimezoneOffset());
  ```

### 正则表达式 regExp

- 字面量方式创建： let r = /at/gim
- 构造函数：let r=new RegExp('at','gim')
- 实例方法
  - exec():专门为捕获组设计。接收一个参数，即应用模版的字符串。
  - test():模式与参数匹配则返回 true

```

```

### 函数 Function

- 函数是对象，函数名是引用。

  ```
      var sum =new Function('arg1','arg2','return arg1 + arg2')
      这样会解析两次（一次是常规的ECMAScript解析，而是解析传入构造函数中的字符串），影响性能
      这对于理解 ‘函数是对象，函数名是引用’非常直观
  ```

  - 没有重载，重复定义相当于覆盖了引用第一个函数的变量
  - 函数表达式和函数声明的区别？
    - 解析器会率先读取函数声明，并使其在执行任何代码之前都可以使用。有一个叫函数声明提升的过程，读取并将函数声明添加到执行环境中，对代码求值时，javascritp 引擎在第一遍声明函数并把它放到源码数顶部。即使调用在在声明之前。
    - 函数表达式只有等解析器执行到它所在的代码行，才会真正到解析执行。它处于初始化语句中。
  - 函数内部属性：argumrnts this

    - arguments:保存着函数对参数对类数组对象，他有一个属性指向执行它的函数 callee。（递归对时候可以用，但是现在不用他了)
      - callee 保存着对当前函数的引用。
      ```
      来写一个高阶函数：递归
      function sum(num){
          if(num<0){
              return 1
          }else{
              return num*arguments.callee(num-1)
          }
      }
      ```
    - this:this 引用的是函数据以执行的环境对象

    ```
        global.color = "red";
        var obj = {
         color: "blue"
        };
        function sayColor() {
         console.log(this.color);
        }
        sayColor()// red
        obj.sayColor = sayColor;
        obj.sayColor(); // blue
        var sayColor1 = obj.sayColor;
        sayColor1(); //red
    ```

    - 牢记 函数名仅仅是一个包含指针的变量而已。因此即使是在不同的环境中执行，全局的 sayColor()函数与 obj.sayColor()指向的仍然是同一个函数。
